

#Данные будем загружать из файла. Для этого используем функцию read_csv.
```{r eval=FALSE}
library(dplyr)
library(ggplot2)
library(readr)
?read_csv
top_companies <- read_csv("top_companies.csv")
top_companies = top_companies %>% select(brand = `Бренды`,
                                         company = `Наименование компании`,
                                         owner = `Ключевые собственники`,
                                         income2016 = `Вырчука, 2016 г.`,
                                         income2015 = `Выручка, 2015 г.`,
                                         region = `Регион`,
                                         industry = `Отрасль`)
```

#Постройте график распределения выручки (представлена в млн. рублей) компаний за 2016 год (income2016). Напоминаем, что для того, чтобы проанализировать распределение числовой переменной, мы используем гистограмму или боксплот.
```{r eval=FALSE}
ggplot() + geom_histogram(data = top_companies, aes(x = income2016))
```

```{r eval=FALSE}
ggplot() + geom_boxplot(data= top_companies, aes(y = income2016))
``````

#Постройте график распределения выручки (представлена в млн. рублей) компаний за 2016 год (income2016). Напоминаем, что для того, чтобы проанализировать распределение числовой переменной, мы используем гистограмму или боксплот.

#Как вы видите, у нас есть очень сильные выбросы, из-за которых бОльшая часть нашего распределения находится у самого начала оси X или же, в случае боксплота, у начала оси Y. Cкладывается впечатление, что выручка для большинства компаний равна 0, но это же не так!. Давайте, чтобы немного улучшить ситуацию, оставим только 95 % наблюдений и по ним построим график. При помощи функции `quantile(top_companies$income2016, 0.95)` мы можем узнать, что значение, которое отделяет 95 % наблюдений -- это 138303.7. Давайте оставим только те наблюдения, у которых income меньше 138303.7, и снова построим график.

```{r eval=FALSE}
q = quantile(top_companies$income2016, 0.95)
q
top_companies %>% 
  filter(income2016 < q) %>%
  ggplot() + 
  geom_histogram(aes(x=income2016))
```
#Какому ключевому собственнику (owner) принадлежит наибольшее количество брендов из нашего топа компаний. Из финального списка удалите NA (функция `na.omit`) и отавьте верхние 5 значений.
#Для того, чтобы оставить первые 5 значений, можно использовать функцию `top_n`

```{r eval=FALSE}
?top_n
top_companies %>% group_by(owner) %>% dplyr::summarise(brand_count = n()) %>% arrange(-brand_count) %>% na.omit() %>% top_n(10)
```


```{r eval=FALSE}
top5_companies = top_companies %>% mutate(difference_income = income2016-income2015) %>% arrange(difference_income) %>% top_n(5)
top5_companies
```

#Найдите топ-3 регионов по медианной выручке компаний (income2016). Запишите результат в дф под названием top3_regions.
```{r eval=FALSE}
top3_regions = top_companies %>% group_by(region) %>% summarize(median_income = median(income2016)) %>% top_n(3, median_income)
top3_regions
```






#Из оригинального датасета оставьте только компании, находящиеся в топе-3 регионов, полученные в предыдущем задании -- поможет оператор `%in%`. Чтобы успешно использовать оператор `%in%`, нужно, при использовании функции filter, в то место, куда мы обычно записываем логические выражения, на основе которых фильтруем датасеты, записать следующее: `region %in% top3_regions$region`. Таким образом, мы оставляем в векторе region только те значения, которые есть в векторе top3_regions$region.
#Постройте график, чтобы сравнить распределение выручки компаний в этих регионах.

```{r eval=FALSE}
p = top_companies %>% filter(region %in% top3_regions$region)
top_companies

ggplot(data = p)+geom_bar(aes(x = region))
  
```
#Найдите топ-5 отраслей (industry) с максимальными выручками брендов и постройте bar plot, в котором на оси X будут названия отраслей, а ось Y будет представлять максимальные значения, которые мы нашли. Не забудьдте, что если мы хотим в качестве значений оси Y использовать значения конкретного столбца, нам нужно указать, что `stat = "identity"`.
#Сделайте так, чтобы столбцы в диаграмме шли по убыванию значения max. Для этого в aes для оси X напишите не просто industry, a `reorder(industry, -max)`.
```{r eval=FALSE}
top_companies %>% filter()
  ggplot() + 
  ...
```

##Часть 2. Вопросы и ответы

#Итак, у нас есть данные, собранные с сайта stackoverflow.com. Это вопросы пользователей, связанные с написанием кода на языке R, ответы на эти вопросы, а также теги, которые были проставлены вопросам. В первую очередь, давайте подгрузим эти данные.

```{r eval=FALSE}
library(dplyr)
questions <- read_csv("~/shared/minor2_2017/1-Intro/data/questions_sample.csv")
answers <- read_csv("~/shared/minor2_2017/1-Intro/data/answers_sample.csv")
tags <- read_csv("~/shared/minor2_2017/1-Intro/data/tags_sample.csv")
questions = dplyr::select(questions, Id, OwnerUserId, Score:Body)
answers = dplyr::select(answers, ParentId, OwnerUserId, answer.score = `Score`, accepted = `IsAcceptedAnswer`, answer.body = `Body`)
```

#А теперь нам их надо соединить. Благо, в пакете `dplyr` для этого есть функция join. Давайте при ее помощи сделаем один датасет, в котором будут вопросы и теги для них.

```{r eval=FALSE}
qtags = left_join(..., ..., by=...)
```

#Теперь давайте найдем самые популярные теги (те, которые чаще всего встречаются в нашем новом датасете). Сделайте bar plot, в котором по оси X будут 10 самых популярных тегов, а ось Y будет показывать, сколько раз они встречаются. Остортируйте столбы по убыванию. Не забудьте удалить NA!

```{r eval=FALSE}
qtags %>% ...
```

#Теперь объединим вопросы и ответы и удалим NA для всего нового датасета. 

```{r eval=FALSE}
qans = ...
qans = na.omit(qans)
```

#Давайте посмотрим, связана ли длина текста ответа с его рейтингом (Score). Для того, чтобы узнать, сколько символов в тексте ответа, нужно использовать функцию stringr::str_length. Какой график наиболее нам подходит для того, чтобы посмотреть связь между двумя количественными переменными? 
Покрасьте цветом ответы в зависимости от того, были ли они приняты автором вопроса или нет (accepted).

```{r eval=FALSE}
ggplot() + ...
```

Задайте вопрос к данным по StackOverflow и ответьте на него.

```{r eval=FALSE}

```

---

А теперь давайте соберем html-отчет и попробуем поделиться им с помощью гистов. 
Инструкцию как пользоваться гистами можно найти тут "~/shared/minor2_2018/gists.pdf"

Не забываем -- для создания html-отчета, нужно чтобы файлик RMarkdown у вас был сохранен в домашней папке. 

Также, многие из вас интересовались, за что отвечают разные мистические надписи, вроде `echo = T` в заголовках чанков (серых кусков с кодом в .Rmd файлах, обозначающиеся ```). Давайте подсмотрим в шпаргалку и поэкспериментируем! 







